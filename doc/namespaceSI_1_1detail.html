<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SI: SI::detail Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="SI-logo-small.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SI
   &#160;<span id="projectnumber">1.7.2</span>
   </div>
   <div id="projectbrief">A header only c++ library that provides type safety and user defined literals for handling pyhsical values defined in the International System of Units.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceSI.html">SI</a></li><li class="navelem"><a class="el" href="namespaceSI_1_1detail.html">detail</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">SI::detail Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Namespace containing implementation details for <a class="el" href="namespaceSI.html">SI</a>.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceSI_1_1detail_1_1parsing"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSI_1_1detail_1_1parsing.html">parsing</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSI_1_1detail_1_1is__ratio.html">is_ratio</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">to check if a template is an instatiation of std::ratio  <a href="structSI_1_1detail_1_1is__ratio.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSI_1_1detail_1_1is__ratio_3_01std_1_1ratio_3_01__num_00_01__den_01_4_01_4.html">is_ratio&lt; std::ratio&lt; _num, _den &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSI_1_1detail_1_1is__unit__t.html">is_unit_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper template to check if a type is a <a class="el" href="structSI_1_1detail_1_1unit__t.html" title="base template class for holding values of type _type to be multiplied with a ratio _ratio ...">unit_t</a> (false for all other types)  <a href="structSI_1_1detail_1_1is__unit__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSI_1_1detail_1_1is__unit__t_3_01const_01unit__t_3_01__symbol_00_01__exponent_00_01__type_00_01__ratio_01_4_01_4.html">is_unit_t&lt; const unit_t&lt; _symbol, _exponent, _type, _ratio &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation to check if a type is a <a class="el" href="structSI_1_1detail_1_1unit__t.html" title="base template class for holding values of type _type to be multiplied with a ratio _ratio ...">unit_t</a> (true if <a class="el" href="structSI_1_1detail_1_1unit__t.html" title="base template class for holding values of type _type to be multiplied with a ratio _ratio ...">unit_t</a>)  <a href="structSI_1_1detail_1_1is__unit__t_3_01const_01unit__t_3_01__symbol_00_01__exponent_00_01__type_00_01__ratio_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSI_1_1detail_1_1is__unit__t_3_01unit__t_3_01__symbol_00_01__exponent_00_01__type_00_01__ratio_01_4_01_4.html">is_unit_t&lt; unit_t&lt; _symbol, _exponent, _type, _ratio &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">non-const specialisation of check above  <a href="structSI_1_1detail_1_1is__unit__t_3_01unit__t_3_01__symbol_00_01__exponent_00_01__type_00_01__ratio_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSI_1_1detail_1_1ratio__gcd.html">ratio_gcd</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSI_1_1detail_1_1ratio__prefix.html">ratio_prefix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">base template for ratio prefix, unusable  <a href="structSI_1_1detail_1_1ratio__prefix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSI_1_1detail_1_1ratio__prefix_3_01std_1_1atto_01_4.html">ratio_prefix&lt; std::atto &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSI_1_1detail_1_1ratio__prefix_3_01std_1_1centi_01_4.html">ratio_prefix&lt; std::centi &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSI_1_1detail_1_1ratio__prefix_3_01std_1_1exa_01_4.html">ratio_prefix&lt; std::exa &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSI_1_1detail_1_1ratio__prefix_3_01std_1_1femto_01_4.html">ratio_prefix&lt; std::femto &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSI_1_1detail_1_1ratio__prefix_3_01std_1_1giga_01_4.html">ratio_prefix&lt; std::giga &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSI_1_1detail_1_1ratio__prefix_3_01std_1_1kilo_01_4.html">ratio_prefix&lt; std::kilo &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSI_1_1detail_1_1ratio__prefix_3_01std_1_1mega_01_4.html">ratio_prefix&lt; std::mega &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSI_1_1detail_1_1ratio__prefix_3_01std_1_1micro_01_4.html">ratio_prefix&lt; std::micro &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSI_1_1detail_1_1ratio__prefix_3_01std_1_1milli_01_4.html">ratio_prefix&lt; std::milli &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSI_1_1detail_1_1ratio__prefix_3_01std_1_1nano_01_4.html">ratio_prefix&lt; std::nano &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSI_1_1detail_1_1ratio__prefix_3_01std_1_1peta_01_4.html">ratio_prefix&lt; std::peta &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSI_1_1detail_1_1ratio__prefix_3_01std_1_1pico_01_4.html">ratio_prefix&lt; std::pico &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSI_1_1detail_1_1ratio__prefix_3_01std_1_1tera_01_4.html">ratio_prefix&lt; std::tera &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSI_1_1detail_1_1unit__symbol__impl.html">unit_symbol_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time string provider for conversion of unit types to stringsa.  <a href="structSI_1_1detail_1_1unit__symbol__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSI_1_1detail_1_1unit__t.html">unit_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">base template class for holding values of type _type to be multiplied with a ratio _ratio  <a href="structSI_1_1detail_1_1unit__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSI_1_1detail_1_1unit__with__common__ratio.html">unit_with_common_ratio</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a7e9aaedc94cb30877243cf6e1c7e5b2b"><td class="memTemplParams" colspan="2">template&lt;int8_t _exponent, typename _type , typename _ratio &gt; </td></tr>
<tr class="memitem:a7e9aaedc94cb30877243cf6e1c7e5b2b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSI_1_1detail.html#a7e9aaedc94cb30877243cf6e1c7e5b2b">time_base_t</a> = <a class="el" href="structSI_1_1detail_1_1unit__t.html">detail::unit_t</a>&lt; 'T', _exponent, _type, _ratio &gt;</td></tr>
<tr class="separator:a7e9aaedc94cb30877243cf6e1c7e5b2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1fe051f6c592daff5cce9a0f9e2fb66f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename std::enable_if&lt; std::is_floating_point&lt; T &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a1fe051f6c592daff5cce9a0f9e2fb66f"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSI_1_1detail.html#a1fe051f6c592daff5cce9a0f9e2fb66f">epsEqual</a> (const T &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="separator:a1fe051f6c592daff5cce9a0f9e2fb66f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45af83e9f353597a58012c58577724fb"><td class="memTemplParams" colspan="2">template&lt;typename _target_type , typename _rhs_T &gt; </td></tr>
<tr class="memitem:a45af83e9f353597a58012c58577724fb"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSI_1_1detail.html#a45af83e9f353597a58012c58577724fb">unit_cast</a> (const _rhs_T &amp;rhs)</td></tr>
<tr class="memdesc:a45af83e9f353597a58012c58577724fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">function to cast between two units of the same type  <a href="#a45af83e9f353597a58012c58577724fb">More...</a><br /></td></tr>
<tr class="separator:a45af83e9f353597a58012c58577724fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2614dd22817f47500394f7311a09b68"><td class="memTemplParams" colspan="2">template&lt;typename _type , char _symbol, int8_t _exponent, typename _rhs_type , typename _ratio , typename std::enable_if&lt; std::is_integral&lt; _type &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ae2614dd22817f47500394f7311a09b68"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSI_1_1detail.html#ae2614dd22817f47500394f7311a09b68">operator/</a> (const _type &amp;lhs, const <a class="el" href="structSI_1_1detail_1_1unit__t.html">unit_t</a>&lt; _symbol, _exponent, _rhs_type, _ratio &gt; &amp;rhs)</td></tr>
<tr class="separator:ae2614dd22817f47500394f7311a09b68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72bcb436f9c71971933bd49859c77b24"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename... &gt; typename _resulting_unit, typename _unit_lhs , typename _unit_rhs &gt; </td></tr>
<tr class="memitem:a72bcb436f9c71971933bd49859c77b24"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSI_1_1detail.html#a72bcb436f9c71971933bd49859c77b24">cross_unit_divide</a> (const _unit_lhs &amp;lhs, const _unit_rhs &amp;rhs)</td></tr>
<tr class="separator:a72bcb436f9c71971933bd49859c77b24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acae9252988e90f68da5060953a32159e"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename... &gt; typename _resulting_unit, typename _unit_lhs , typename _unit_rhs &gt; </td></tr>
<tr class="memitem:acae9252988e90f68da5060953a32159e"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSI_1_1detail.html#acae9252988e90f68da5060953a32159e">cross_unit_multiply</a> (const _unit_lhs &amp;lhs, const _unit_rhs &amp;rhs)</td></tr>
<tr class="separator:acae9252988e90f68da5060953a32159e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c9596cb33a11f2dd65866bf958848d7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSI_1_1detail.html#a1c9596cb33a11f2dd65866bf958848d7">BUILD_UNIT_FROM_DIVISON</a> (<a class="el" href="namespaceSI.html#a53d44a469b4c311293e6fa4e8cfe68b7">electric_conductance_t</a>, <a class="el" href="namespaceSI.html#a24bd428fe03851644bdac64aa16e07a3">electric_current_t</a>, <a class="el" href="namespaceSI.html#a627c04cc2fff54fde28c7acb77c023d4">electric_potential_t</a>) template&lt; typename _type</td></tr>
<tr class="separator:a1c9596cb33a11f2dd65866bf958848d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb737a45e6f390083bd9b02b285b1dcf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSI_1_1detail.html#abb737a45e6f390083bd9b02b285b1dcf">BUILD_UNIT_FROM_DIVISON</a> (<a class="el" href="namespaceSI.html#af3f0de57402c8b73307be807dee7f6a5">electric_resistance_t</a>, <a class="el" href="namespaceSI.html#a627c04cc2fff54fde28c7acb77c023d4">electric_potential_t</a>, <a class="el" href="namespaceSI.html#a24bd428fe03851644bdac64aa16e07a3">electric_current_t</a>) template&lt; typename _type</td></tr>
<tr class="separator:abb737a45e6f390083bd9b02b285b1dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Namespace containing implementation details for <a class="el" href="namespaceSI.html">SI</a>. </p>
<p>Namespace containing all <a class="el" href="namespaceSI.html">SI</a> units.</p>
<p>This file is part of "SI" version 1.7.2 A header only c++ library that provides type safety and user defined literals for handling pyhsical values defined in the International System of Units</p>
<p><a href="https://github.com/bernedom/SI">https://github.com/bernedom/SI</a></p>
<p>SPDX-License-Identifier: MIT </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a7e9aaedc94cb30877243cf6e1c7e5b2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e9aaedc94cb30877243cf6e1c7e5b2b">&#9670;&nbsp;</a></span>time_base_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int8_t _exponent, typename _type , typename _ratio &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceSI_1_1detail.html#a7e9aaedc94cb30877243cf6e1c7e5b2b">SI::detail::time_base_t</a> = typedef <a class="el" href="structSI_1_1detail_1_1unit__t.html">detail::unit_t</a>&lt;'T', _exponent, _type, _ratio&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a1c9596cb33a11f2dd65866bf958848d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c9596cb33a11f2dd65866bf958848d7">&#9670;&nbsp;</a></span>BUILD_UNIT_FROM_DIVISON() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SI::detail::BUILD_UNIT_FROM_DIVISON </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSI.html#a53d44a469b4c311293e6fa4e8cfe68b7">electric_conductance_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSI.html#a24bd428fe03851644bdac64aa16e07a3">electric_current_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSI.html#a627c04cc2fff54fde28c7acb77c023d4">electric_potential_t</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Builds conductance from 1/resistance, to avoid include cycles the base <a class="el" href="structSI_1_1detail_1_1unit__t.html" title="base template class for holding values of type _type to be multiplied with a ratio _ratio ...">unit_t</a> is used instead of the type alias electric_resistance_t </p>

</div>
</div>
<a id="abb737a45e6f390083bd9b02b285b1dcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb737a45e6f390083bd9b02b285b1dcf">&#9670;&nbsp;</a></span>BUILD_UNIT_FROM_DIVISON() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SI::detail::BUILD_UNIT_FROM_DIVISON </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSI.html#af3f0de57402c8b73307be807dee7f6a5">electric_resistance_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSI.html#a627c04cc2fff54fde28c7acb77c023d4">electric_potential_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSI.html#a24bd428fe03851644bdac64aa16e07a3">electric_current_t</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Builds conductance from 1/conductance, to avoid include cycles the base <a class="el" href="structSI_1_1detail_1_1unit__t.html" title="base template class for holding values of type _type to be multiplied with a ratio _ratio ...">unit_t</a> is used instead of the type alias electric_conductance_t </p>

</div>
</div>
<a id="a72bcb436f9c71971933bd49859c77b24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72bcb436f9c71971933bd49859c77b24">&#9670;&nbsp;</a></span>cross_unit_divide()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename... &gt; typename _resulting_unit, typename _unit_lhs , typename _unit_rhs &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto SI::detail::cross_unit_divide </td>
          <td>(</td>
          <td class="paramtype">const _unit_lhs &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _unit_rhs &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>divide a value of a certain unit with another value of a possibly different type resulting in a new type, the resulting exponent is specified by resulting unit using a variadic template to simplify usage of implementation the internal type of the result is the internal type of lhs </p>

</div>
</div>
<a id="acae9252988e90f68da5060953a32159e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acae9252988e90f68da5060953a32159e">&#9670;&nbsp;</a></span>cross_unit_multiply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename... &gt; typename _resulting_unit, typename _unit_lhs , typename _unit_rhs &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto SI::detail::cross_unit_multiply </td>
          <td>(</td>
          <td class="paramtype">const _unit_lhs &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _unit_rhs &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>multiply a value of a unit witn another value of a possibly different value resulting in a value of a new type with exponent 1 the internal type of the result is the internal type of lhs </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>add function that works with variable exponent units and remove special typedefs for time </dd></dl>

</div>
</div>
<a id="a1fe051f6c592daff5cce9a0f9e2fb66f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fe051f6c592daff5cce9a0f9e2fb66f">&#9670;&nbsp;</a></span>epsEqual()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename std::enable_if&lt; std::is_floating_point&lt; T &gt;::value &gt;::type *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool SI::detail::epsEqual </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae2614dd22817f47500394f7311a09b68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2614dd22817f47500394f7311a09b68">&#9670;&nbsp;</a></span>operator/()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _type , char _symbol, int8_t _exponent, typename _rhs_type , typename _ratio , typename std::enable_if&lt; std::is_integral&lt; _type &gt;::value &gt;::type *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto SI::detail::operator/ </td>
          <td>(</td>
          <td class="paramtype">const _type &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSI_1_1detail_1_1unit__t.html">unit_t</a>&lt; _symbol, _exponent, _rhs_type, _ratio &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>operator to divide primitive type by unit encapsulating the same type template specialisation handling integer types  unit with negative exponent</p>
<p>operator to divide primitive type by unit encapsulating the same type template specialisation for floating point types, to avoid possible loss of precision when adjusting for ratio  unit with negative exponent </p>

</div>
</div>
<a id="a45af83e9f353597a58012c58577724fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45af83e9f353597a58012c58577724fb">&#9670;&nbsp;</a></span>unit_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _target_type , typename _rhs_T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto SI::detail::unit_cast </td>
          <td>(</td>
          <td class="paramtype">const _rhs_T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>function to cast between two units of the same type </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
